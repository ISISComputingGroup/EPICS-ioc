# Set the PROTOCOL PV to LEGACY
# This facilitates the UI to show/hide protocol specific settings
record (stringin, "$(P)PROTOCOL")
{
    field(DESC, "Inform the UI which protocol to use")
    field(DTYP, "Soft Channel")
    field(SCAN, "Passive")
    field(VAL, "LEGACY")
    field(PINI, "YES")
}


# # Readback from Cn part of Examine command return.
record(mbbi, "$(P)CONTROL") {
  field(DESC, "Control status")
  field(DTYP, "Soft Channel")
  field(SCAN, "1 second")
  field(ZRST, "Local & Locked")
  field(ZRVL, "0")
  field(ZRSV, "NO_ALARM")
  field(ONST, "Remote & Locked")
  field(ONVL, "1")
  field(ONSV, "NO_ALARM")
  field(TWST, "Local & Unlocked")
  field(TWVL, "2")
  field(TWSV, "NO_ALARM")
  field(THST, "Remote & Unlocked")
  field(THVL, "3")
  field(THSV, "NO_ALARM")
  
  # Modes 4-7 come back from device. Manual does not make it clear what the
  # differences are. Keeping them as separate items in case they are useful
  # for diagnostics later on.
  field(FRST, "Auto-Run-Down")
  field(FRVL, "4")
  field(FRSV, "MAJOR")
  field(FVST, "Auto-Run-Down")
  field(FVVL, "5")
  field(FVSV, "MAJOR")
  field(SXST, "Auto-Run-Down")
  field(SXVL, "6")
  field(SXSV, "MAJOR")
  field(SVST, "Auto-Run-Down")
  field(SVVL, "7")
  field(SVSV, "MAJOR")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:CONTROL")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
  info(alarm, "IPS")
}

# Grab remote vs local control
record(mbbo, "$(P)CONTROL:SP") {
  field(DESC, "Set remote/local control")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(OUT,  "@OxInstIPS.protocol setControl $(PORT)")
  field(ZRST, "Local & Locked")
  field(ZRVL, "0")
  field(ONST, "Remote & Locked")
  field(ONVL, "1")
  field(TWST, "Local & Unlocked")
  field(TWVL, "2")
  field(THST, "Remote & Unlocked")
  field(THVL, "3")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:CONTROL:SP")
  field(SDIS, "$(P)DISABLE")
}

# Readback from An part of Examine command return.
# Hold means maintaining present current.
# Clamped means you cannot adjust it - powers up in this 
# state.  Only the set activity hold command can get out
# of the clamped state.  Hold will interrupt a sweep.
record(mbbi, "$(P)ACTIVITY") {
  field(DESC, "Activity status")
  field(DTYP, "Soft Channel")
  field(SCAN, "1 second")
  field(ZRST, "Hold")
  field(ZRVL, "0")
  field(ZRSV, "NO_ALARM")
  field(ONST, "To Setpoint")
  field(ONVL, "1")
  field(ONSV, "NO_ALARM")
  field(TWST, "To Zero")
  field(TWVL, "2")
  field(TWSV, "NO_ALARM")
  field(FRST, "Clamped")
  field(FRVL, "4")
  field(FRSV, "MAJOR")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:ACTIVITY")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}


# The current at which a trip last occurred.  Am not sure if by trip, they mean
# a quench or a problem with the level meter.  Believe the unit will take the current
# and field to zero if there is a trip, so this parameter preserves what was happening
# at the time of the trip.
record(ai, "$(P)CURR:TRIP") {
  field(DESC, "Trip current readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS.protocol getTripCurrent $(PORT)")
  field(EGU,  "A")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:TRIPCURRENT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}


# The field at which a trip last occurred.  See current for explanation.
record(ai, "$(P)FIELD:TRIP") {
  field(DESC, "Trip field readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS.protocol getTripField $(PORT)")
  field(EGU,  "T")
  field(PREC, "5")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:TRIPFIELD")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The current being provided to the heater.
record(ai, "$(P)HEATER:CURR") {
  field(DESC, "Heater current readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS.protocol getHeaterCurrent $(PORT)")
  field(EGU,  "mA")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:HEATERCURRENT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The lower limit for the current.  This refers to a limit on the controller and
# is nothing to do with EPICS record limit or alarm fields.
record(ai, "$(P)CURR:LIMIT:NEG") {
  field(DESC, "Neg current limit readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS.protocol getNegCurrentLimit $(PORT)")
  field(EGU,  "A")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:NEGCURRENTLIMIT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The higher limit for the current.  This refers to a limit on the controller and
# is nothing to do with EPICS record limit or alarm fields.
record(ai, "$(P)CURR:LIMIT:POS") {
  field(DESC, "Pos current limit readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS.protocol getPosCurrentLimit $(PORT)")
  field(EGU,  "A")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:POSCURRENTLIMIT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}


# # Run the Examine Status command, X.
# The reply comes back and is split amongst other records.
record(stringin, "$(P)GET:STATUS") {
  field(DESC, "Examine status")
  field(DTYP, "stream")
  field(INP, "@OxInstIPS.protocol getStatus($(P)) $(PORT)")
  field(SCAN, "1 second")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:DONOTHING")
  field(SDIS, "$(P)DISABLE")
}

# # Readback from m of Xmn part of Examine command return.
record(mbbi, "$(P)STS:SYSTEM:FAULT") {
  field(DESC, "System fault status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZRST, "Normal")
  field(ZRVL, "0")
  field(ZRSV, "NO_ALARM")
  field(ONST, "Quenched")
  field(ONVL, "1")
  field(ONSV, "MAJOR")
  field(TWST, "Overheated")
  field(TWVL, "2")
  field(TWSV, "MAJOR")
  field(FRST, "Warming Up")
  field(FRVL, "4")
  field(FRSV, "MAJOR")
  field(EIST, "Fault")
  field(EIVL, "8")
  field(EISV, "MAJOR")
  
  info(archive, "VAL")
}

# # Readback from n of Xmn part of Examine command return.
record(mbbi, "$(P)STS:SYSTEM:LIMIT") {
  field(DESC, "System limit status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZRST, "Normal")
  field(ZRVL, "0")
  field(ZRSV, "NO_ALARM")
  field(ONST, "On +ve V Limit")
  field(ONVL, "1")
  field(ONSV, "MINOR")
  field(TWST, "On -ve V Limit")
  field(TWVL, "2")
  field(TWSV, "MINOR")
  field(FRST, "Current too -ve")
  field(FRVL, "4")
  field(FRSV, "MINOR")
  field(EIST, "Current too +ve")
  field(EIVL, "8")
  field(EISV, "MINOR")
  
  info(archive, "VAL")
}

# Readback from Hn part of Examine command return.
# 0 switch closed, 1 switch open, 2 switch closed, 5 heater is on but low current, 8 no switch fitted.
record(mbbi, "$(P)HEATER:STATUS") {
  field(DESC, "Heater status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZRST, "Off Mag at 0")
  field(ZRVL, "0")
  field(ONST, "On")
  field(ONVL, "1")
  field(TWST, "Off Mag at F")
  field(TWVL, "2")
  field(FVST, "Heater Fault")
  field(FVVL, "5")
  field(FVSV, "MAJOR")
  field(EIST, "No Switch")
  field(EIVL, "8")
  field(EISV, "MAJOR")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:HEATER:STATUS")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}


# To capture bits of mismatching status protocol.
# We do not do much with it at the moment.
record(stringin, "$(P)DBG:STS:MISMATCH") {
  field(DESC, "Mismatching protocol string.")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
}

# Diddle with the comms and reported resolution.
# This is the nasty Q command which does not reply and whose
# info does not get reported by the status command.
# This may be needed after power cycle of IPS or if it has
# been connected to the Oxford Instruments Windows Application
# to allow EPICS to talk to it and to allow the resolution to be extended.
# Are not supporting setting these things individually, just setting
# what we want.
record(ao, "$(P)SET:COMMSRES") {
  field(DESC, "Set ext. resn, no LF")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(VAL, "6")
  field(PINI, "YES")
  field(OUT,  "@OxInstIPS.protocol setCommsResExtended $(PORT)")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:DONOTHING")
  field(SDIS, "$(P)DISABLE")
}

# Diddle with the comms wait interval.
# Probably will not need this, but put it here in case we do.  Will not put access to this
# on the GUI.
record(ao, "$(P)SET:WAITINTERVAL") {
  field(DESC, "Set wait interval")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(EGU, "ms")
  field(OUT,  "@OxInstIPS.protocol setWaitInterval $(PORT)")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:DONOTHING")
  field(SDIS, "$(P)DISABLE")
}

record(mbbo, "$(P)SIM:SWEEPMODE:PARAMS") {
  field(ZRST, "Amps Fast")
  field(ZRVL, "0")
  field(ONST, "Tesla Fast")
  field(ONVL, "1")
  field(TWST, "Amps Fast")
  field(TWVL, "2")
  field(THST, "Tesla Fast")
  field(THVL, "3")
  field(FRST, "Amps Slow")
  field(FRVL, "4")
  field(FVST, "Tesla Slow")
  field(FVVL, "5")
  field(SXST, "Amps Slow")
  field(SXVL, "6")
  field(SVST, "Tesla Slow")
  field(SVVL, "7")
  field(EIST, "Amps Unaffected")
  field(EIVL, "8")
  field(NIST, "Tesla Unaffected")
  field(NIVL, "9")
}

# To set the sweep and display mode - its a bit confusing as there
# are duplicates, but we do not present this choice to the user.
#
record(mbbo, "$(P)SWEEPMODE:PARAMS:SP") {
  field(DESC, "Set sweep and display mode.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(ZRST, "Amps Fast")
  field(ZRVL, "0")
  field(ONST, "Tesla Fast")
  field(ONVL, "1")
  field(TWST, "Amps Fast")
  field(TWVL, "2")
  field(THST, "Tesla Fast")
  field(THVL, "3")
  field(FRST, "Amps Slow")
  field(FRVL, "4")
  field(FVST, "Tesla Slow")
  field(FVVL, "5")
  field(SXST, "Amps Slow")
  field(SXVL, "6")
  field(SVST, "Tesla Slow")
  field(SVVL, "7")
  field(EIST, "Amps Unaffected")
  field(EIVL, "8")
  field(NIST, "Tesla Unaffected")
  field(NIVL, "9")
  field(OUT,  "@$(PROTO) setMode $(PORT)")

  field(VAL, "3")
  field(PINI, "YES")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:SWEEPMODE:PARAMS:SP")
  field(SDIS, "$(P)DISABLE")
}

alias("$(P)SIM:SWEEPMODE:PARAMS", "$(P)SIM:SPEEPMODE:PARAMS:SP")


record(mbbo, "$(P)SIM:CONTROL") {
  field(ZRST, "Local & Locked")
  field(ZRVL, "0")
  field(ONST, "Remote & Locked")
  field(ONVL, "1")
  field(TWST, "Local & Unlocked")
  field(TWVL, "2")
  field(THST, "Remote & Unlocked")
  field(THVL, "3")
}

alias("$(P)SIM:CONTROL", "$(P)SIM:CONTROL:SP")
