# Set the PROTOCOL PV to SCPI
# This facilitates the UI to show/hide protocol specific settings
record (stringin, "$(P)PROTOCOL")
{
    field(DESC, "Inform the UI which protocol to use")
    field(DTYP, "Soft Channel")
    field(SCAN, "Passive")
    field(VAL, "SCPI")
    field(PINI, "YES")
}


# Readback from STAT:DEV:GRPZ:PSU:ACTN command return (in getActivity()).
# Hold means maintaining present current.
# Clamped means you cannot adjust it - powers up in this 
# state.  Only the set activity hold command can get out
# of the clamped state.  Hold will interrupt a sweep.
record(mbbi, "$(P)ACTIVITY") {
  field(DESC, "Activity status")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getActivity($(P)) $(PORT)")
  field(ZRST, "Hold")
  field(ZRVL, "0")
  field(ZRSV, "NO_ALARM")
  field(ONST, "To Setpoint")
  field(ONVL, "1")
  field(ONSV, "NO_ALARM")
  field(TWST, "To Zero")
  field(TWVL, "2")
  field(TWSV, "NO_ALARM")
  field(FRST, "Clamped")
  field(FRVL, "4")
  field(FRSV, "MAJOR")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:ACTIVITY")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}





# --------------- The following work around limitation of getting legacy status from SCPI protocol -------------
# Note that the mbbiDirect is split into individual bi records for each status bit, via the
# scpi_system_alarms_discrete.template and substitution files.

# Get the status DWORD from each group UID
record(mbbiDirect, "$(P)GET:MAGNET:SUPPLY:STATUS") {
  field(DESC, "Examine status")
  field(DTYP, "stream")
  field(INP, "@OxInstIPS_SCPI.protocol getMagnetSupplyStatus($(P)) $(PORT)")
  field(NOBT, "32")
  field(SCAN, "1 second")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:DONOTHING")
  field(SDIS, "$(P)DISABLE")
}

# The over temperature status should be an or'd output from the numerous temperature alarms
record(calc, "$(P)MAGNET:SUPPLY:STATUS:OVERTEMP:CALC") {
  field(DESC, "Temperature status calc (combined)")
  field(SCAN, "Passive")
  field(INPA, "$(P)MAGNET:SUPPLY:STATUS:OTRUNDOWNRES CP MS")
  field(INPB, "$(P)MAGNET:SUPPLY:STATUS:OTSENSERES CP MS")
  field(INPC, "$(P)MAGNET:SUPPLY:STATUS:OTPCB CP MS")
  field(INPD, "$(P)MAGNET:SUPPLY:STATUS:OTSENSEAMP CP MS")
  field(INPE, "$(P)MAGNET:SUPPLY:STATUS:OTAMP1 CP MS")
  field(INPF, "$(P)MAGNET:SUPPLY:STATUS:OTAMP2 CP MS")
  field(CALC, "A|B|C|D|E|F")
}

# Determine the Over Temperature status from the or'd calc record (OVERTEMP:CALC)
record(bi, "$(P)MAGNET:SUPPLY:STATUS:OVERTEMP") {
  field(DESC, "Temperature status (combined)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)MAGNET:SUPPLY:STATUS:OVERTEMP:CALC CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# --------------------------------------------------------------------------------------------------------------

## Derive the SYSTEM:HWFAULT status from the status bits
## This collates the various possible hardware faults into a single record,
## which in the legacy protocol is a single value (Xm bit 4).
record(calc, "$(P)STS:SYSTEM:HWFAULT:CALC") {
  field(DESC, "System hardware fault status calc")
  field(SCAN, "Passive")
  field(INPA, "$(P)MAGNET:SUPPLY:STATUS:SWHTRMISMATCH CP MS")
  field(INPB, "$(P)MAGNET:SUPPLY:STATUS:CALIBFAIL CP MS")
  field(INPC, "$(P)MAGNET:SUPPLY:STATUS:FWFAIL CP MS")
  field(INPD, "$(P)MAGNET:SUPPLY:STATUS:RRFAIL CP MS")
  field(INPE, "$(P)MAGNET:SUPPLY:STATUS:RS485FAIL CP MS")
  field(INPF, "$(P)MAGNET:SUPPLY:STATUS:CATCH CP MS")
  field(INPG, "$(P)MAGNET:SUPPLY:STATUS:PWMCUTOFF CP MS")
  field(INPH, "$(P)MAGNET:SUPPLY:STATUS:VADCERROR CP MS")
  field(INPI, "$(P)MAGNET:SUPPLY:STATUS:IADCERROR CP MS")
  field(CALC, "(A>0||B>0||C>0||D>0||E>0||F>0||G>0||H>0||I>0) ? 1 : 0")
}

## Derive the SYSTEM:FAULT status from the status bits
## This collates the various possible faults into a single record, in alignment with the legacy protocol.
record(calc, "$(P)STS:SYSTEM:FAULT:CALC") {
  field(DESC, "System fault status calc")
  field(SCAN, "Passive")
  field(INPA, "$(P)MAGNET:SUPPLY:STATUS:QUENCHED CP MS")
  field(INPB, "$(P)MAGNET:SUPPLY:STATUS:OVERTEMP CP MS")
  field(INPC, "$(P)STS:SYSTEM:HWFAULT:CALC CP MS")
  field(CALC, "(A>0) ? 1 : (B>0) ? 2 : (C>0) ? 8 : 0")
}

# # Readback from m of Xmn part of Examine command return.
record(mbbi, "$(P)STS:SYSTEM:FAULT") {
  field(DESC, "System fault status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP,  "$(P)STS:SYSTEM:FAULT:CALC CP MS")
  field(ZRST, "Normal")
  field(ZRVL, "0")
  field(ZRSV, "NO_ALARM")
  field(ONST, "Quenched")
  field(ONVL, "1")
  field(ONSV, "MAJOR")
  field(TWST, "Overheated")
  field(TWVL, "2")
  field(TWSV, "MAJOR")
  field(FRST, "Warming Up")
  field(FRVL, "4")
  field(FRSV, "MAJOR")
  field(EIST, "Fault")
  field(EIVL, "8")
  field(EISV, "MAJOR")
  
  info(archive, "VAL")
}

# Readback from SWHT command.
# OFF -> switch closed, ON -> switch open.
record(mbbi, "$(P)HEATER:STATUS") {
  field(DESC, "Heater status")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getHeaterStatus $(PORT)")
  field(ZRST, "Off")
  field(ZRVL, "0")
  field(ONST, "On")
  field(ONVL, "1")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:HEATER:STATUS")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}


# To capture bits of mismatching status protocol.
# We do not do much with it at the moment.
record(stringin, "$(P)DBG:STS:MISMATCH") {
  field(DESC, "Mismatching protocol string.")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
}

# In the legacy version, this used to be the readback from n of Mmn part of Examine command return.
# 0 output constant, 1, 2, 3 output changing
# The SCPI protocol doesn't directly offer this, so it has to be derived via the ACTIVITY record (DEV:GRPZ:PSU:ACTN)
# Direction from Alex Jones: "A response of HOLD or CLMP would be equivalent to n=0 in the response of the X command
# in the old protocol. Responses of RTOS or RTOZ would be equivalent to n=1.
# There is no equivalent for the m=0,1 fast/slow ramps, but we do not use this feature anyway."

record(calcout, "$(P)_SWEEPMODE:SWEEP:CALC") {
  field(INPA, "$(P)ACTIVITY.RVAL CP")
  # 0 = HOLD, 1 = RTOS, 2 = RTOZ, 4 = CLMP
  field(CALC, "((A==0)||(A==4))?0:1")
  field(OUT, "$(P)STS:SWEEPMODE:SWEEP PP")
  field(OOPT, "Every Time")
}

# This record has been added to the SCPI implementation simply to satisfy the state machine logic
# in cryomagnet.st. The legacy record is mbbo, but this is mbbi as it does not actually set
# anything in the device.
#
record(mbbi, "$(P)SWEEPMODE:PARAMS:SP") {
  field(DESC, "Set sweep and display mode.")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(ZRST, "Amps Fast")
  field(ZRVL, "0")
  field(ONST, "Tesla Fast")
  field(ONVL, "1")
  field(TWST, "Amps Fast")
  field(TWVL, "2")
  field(THST, "Tesla Fast")
  field(THVL, "3")
  field(FRST, "Amps Slow")
  field(FRVL, "4")
  field(FVST, "Tesla Slow")
  field(FVVL, "5")
  field(SXST, "Amps Slow")
  field(SXVL, "6")
  field(SVST, "Tesla Slow")
  field(SVVL, "7")
  field(EIST, "Amps Unaffected")
  field(EIVL, "8")
  field(NIST, "Tesla Unaffected")
  field(NIVL, "9")

  field(VAL, "3")
  field(PINI, "YES")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:SWEEPMODE:PARAMS:SP")
  field(SDIS, "$(P)DISABLE")
}

# The temperature of the magnet MB1.T1
record(ai, "$(P)TEMP:MAGNET") {
  field(DESC, "Magnet temperature")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getMagnetTemperature $(PORT)")
  field(EGU,  "K")
  field(PREC, "4")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:TEMP:MAGNET")
  field(SDIS, "$(P)DISABLE")

  info(archive, "VAL")
}

# The temperature of the lambda plate DB8.T1
record(ai, "$(P)TEMP:LAMBDAPLATE") {
  field(DESC, "DB8.T1 temperature")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getLambdaPlateTemperature $(PORT)")
  field(EGU,  "K")
  field(PREC, "4")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:TEMP:LAMBDAPLATE")
  field(SDIS, "$(P)DISABLE")

  info(archive, "VAL")
}

# The temperature of the lambda plate DB8.T1
record(ai, "$(P)PRESSURE") {
  field(DESC, "DB5.P1 pressure")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getPressure $(PORT)")
  field(EGU,  "mBar")
  field(PREC, "4")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:PRESSURE")
  field(SDIS, "$(P)DISABLE")

  info(archive, "VAL")
}
