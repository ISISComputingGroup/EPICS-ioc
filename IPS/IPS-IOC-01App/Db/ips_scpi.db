# Set the PROTOCOL PV to SCPI
# This facilitates the UI to show/hide protocol specific settings
record (stringin, "$(P)PROTOCOL")
{
    field(DESC, "Inform the UI which protocol to use")
    field(DTYP, "Soft Channel")
    field(SCAN, "Passive")
    field(VAL, "SCPI")
    field(PINI, "YES")
}

record(bo, "$(P)SIM")
{
    field(SCAN, "Passive")
    field(DTYP, "Soft Channel")
    field(ZNAM, "NO")
    field(ONAM, "YES")
    field(VAL, "$(RECSIM=0)")
    field(PINI, "YES")
}

record(bo, "$(P)DISABLE")
{
    field(DESC, "Disable comms")
    field(PINI, "YES")
    field(VAL, "$(DISABLE=0)")
    field(OMSL, "supervisory")
    field(ZNAM, "COMMS ENABLED")
    field(ONAM, "COMMS DISABLED")
}

#########################################################
# START OF RECORDS FOR READBACK FROM VERSION COMMAND.
# # Readback of the instrument model and version info.
# # Run the Version command, V.
# # The string was too long to put model and version into same record.
# # Scan this once, probably not needed again.
# The reply comes back and is split amongst other records in the StreamDevice protocol file.
record(stringin, "$(P)GET:VERSION") {
  field(DESC, "Examine status")
  field(DTYP, "stream")
  field(INP,  "@OxInstIPS_SCPI.protocol getVersion($(P)) $(PORT)")
  field(PINI, "YES")
  field(FLNK, "$(P)MODEL")
  field(SCAN, "Passive")
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:DONOTHING")
  field(SDIS, "$(P)DISABLE")
}

# Updated in GET:VERSION call to getVersion()
record(stringin, "$(P)MODEL") {
  field(DESC, "Model")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(FLNK, "$(P)VERSION")
}

# Updated in GET:VERSION call to getVersion()
record(stringin, "$(P)VERSION") {
  field(DESC, "Firmware version.")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
}

# Readback from STAT:DEV:GRPZ:PSU:ACTN command return (in getActivity()).
# Hold means maintaining present current.
# Clamped means you cannot adjust it - powers up in this 
# state.  Only the set activity hold command can get out
# of the clamped state.  Hold will interrupt a sweep.
record(mbbi, "$(P)ACTIVITY") {
  field(DESC, "Activity status")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getActivity($(P)) $(PORT)")
  field(ZRST, "Hold")
  field(ZRVL, "0")
  field(ZRSV, "NO_ALARM")
  field(ONST, "To Setpoint")
  field(ONVL, "1")
  field(ONSV, "NO_ALARM")
  field(TWST, "To Zero")
  field(TWVL, "2")
  field(TWSV, "NO_ALARM")
  field(FRST, "Clamped")
  field(FRVL, "4")
  field(FRSV, "MAJOR")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:ACTIVITY")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# Hold means maintaining present current.
# Clamped means you cannot adjust it - powers up in this 
# state.  Only the set activity hold command can get out
# of the clamped state.  Hold will interrupt a sweep.
record(mbbo, "$(P)ACTIVITY:SP") {
  field(DESC, "Activity control")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(OUT,   "@OxInstIPS_SCPI.protocol setActivity $(PORT)")
  field(ZRST, "Hold")
  field(ZRVL, "0")
  field(ONST, "To Setpoint")
  field(ONVL, "1")
  field(TWST, "To Zero")
  field(TWVL, "2")
  field(FRST, "Clamp")
  field(FRVL, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:ACTIVITY:SP")
  field(SDIS, "$(P)DISABLE")
}

# Think this is the present current the unit is trying to supply.
record(ai, "$(P)CURR") {
  field(DESC, "Demand current readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getDemandCurrent $(PORT)")
  field(EGU,  "A")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:CURRENT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The present current setpoint.
record(ai, "$(P)CURR:SP:RBV") {
  field(DESC, "Setpoint current readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getSetpointCurrent $(PORT)")
  field(EGU,  "A")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:CURRENT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The present voltage.
record(ai, "$(P)SUPPLY:VOLT") {
  field(DESC, "Supply voltage readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getSupplyVoltage $(PORT)")
  field(EGU,  "V")
  field(PREC, "8")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:SUPPLY:VOLT")
  field(SDIS, "$(P)DISABLE")
  
  field(FLNK, "$(P)SUPPLY:VOLT:_STABILITY:BUF")
  
  info(archive, "VAL")
}

record(compress, "$(P)SUPPLY:VOLT:_STABILITY:BUF") {
  field(INP, "$(P)SUPPLY:VOLT")
  field(ALG, "Circular Buffer")
  field(NSAM, "5")
  field(FLNK, "$(P)SUPPLY:VOLT:_STABILITY:LOW")
}

record(compress, "$(P)SUPPLY:VOLT:_STABILITY:LOW") {
  field(INP, "$(P)SUPPLY:VOLT:_STABILITY:BUF")
  field(ALG, "N to 1 Low Value")
  field(NSAM, "1")
  field(N, "5")
  field(FLNK, "$(P)SUPPLY:VOLT:_STABILITY:HIGH")
}

record(compress, "$(P)SUPPLY:VOLT:_STABILITY:HIGH") {
  field(INP, "$(P)SUPPLY:VOLT:_STABILITY:BUF")
  field(ALG, "N to 1 High Value")
  field(NSAM, "1")
  field(N, "5")
  field(FLNK, "$(P)SUPPLY:VOLT:_STABILITY:CALC")
}

record(calcout, "$(P)SUPPLY:VOLT:_STABILITY:CALC") {
  field(INPA, "$(P)SUPPLY:VOLT:_STABILITY:HIGH")
  field(INPB, "$(P)SUPPLY:VOLT:_STABILITY:LOW")
  field(CALC, "ABS(A-B)<$(STABILITY_VOLTAGE)")
  field(OUT, "$(P)SUPPLY:VOLT:STABLE PP")
  field(OOPT, "Every Time")
}

record(bo, "$(P)SUPPLY:VOLT:STABLE") {
  field(ZNAM, "NO")
  field(ONAM, "YES")
  info(archive, "VAL")
}

# The present current measured.
record(ai, "$(P)MAGNET:CURR:MEAS") {
  field(DESC, "Measured magnet current readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getMeasuredMagnetCurrent $(PORT)")
  field(EGU,  "A")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:MAGNET:CURR:MEAS")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The present sweeprate for current.
record(ai, "$(P)CURR:RATE") {
  field(DESC, "Current sweep rate readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getCurrentSweepRate $(PORT)")
  field(EGU,  "A/min")
  field(PREC, "3")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:CURR:RATE")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The field the unit is attempting to create.
record(ai, "$(P)FIELD") {
  field(DESC, "Demand field readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getDemandField $(PORT)")
  field(EGU,  "T")
  field(PREC, "5")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:FIELD")
  field(SDIS, "$(P)DISABLE")
  
  info(INTEREST, "LOW")
  info(archive, "VAL")
}

record(ao, "$(P)FIELD:SP") {
  field(DESC, "Set setpoint field")
  field(SCAN, "Passive")
  field(EGU,  "T")
  field(PREC, "5")
  field(DRVH, "$(MAX_FIELD)")
  field(DRVL, "-$(MAX_FIELD)")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:FIELD")
  field(SDIS, "$(P)DISABLE")
  info(archive, "VAL")
}

# Set the Field Setpoint (i.e. the field the unit will go to and hold for the magnet.)
record(ao, "$(P)FIELD:SP:_RAW") {
  field(DESC, "Send raw field to box")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(OUT,  "@OxInstIPS_SCPI.protocol setSetpointField $(PORT)")
  field(EGU,  "T")
  field(PREC, "5")
  field(DRVH, "$(MAX_FIELD)")
  field(DRVL, "-$(MAX_FIELD)")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:FIELD")
  field(SDIS, "$(P)DISABLE")
  info(archive, "VAL")
}

# The present field setpoint.  The target field the unit will aim for when
# told to go to the setpoint.
record(ai, "$(P)FIELD:SP:RBV") {
  field(DESC, "Setpoint field readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getSetpointField $(PORT)")
  field(EGU,  "T")
  field(PREC, "5")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:FIELD")
  field(SDIS, "$(P)DISABLE")
  info(archive, "VAL")
}

# The present sweeprate (a.k.a. ramprate) for adjusting the field.
record(ai, "$(P)FIELD:RATE") {
  field(DESC, "Field sweep rate readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getFieldSweepRate $(PORT)")
  field(EGU,  "T/min")
  field(PREC, "4")
  
  field(LOLO, "0")
  field(LLSV, "MAJOR")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:FIELD:RATE")
  field(SDIS, "$(P)DISABLE")
  info(INTEREST, "HIGH")
  info(archive, "VAL")
}

record(ao, "$(P)FIELD:RATE:SP") {
  field(DESC, "Set field sweep rate")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(OUT,   "@OxInstIPS_SCPI.protocol setFieldSweepRate $(PORT)")
  field(EGU,  "T/min")
  field(PREC, "4")
  field(DRVH, "$(MAX_SWEEP_RATE)")
  field(DRVL, "0")
  field(ASG, "$(MANAGER_ASG)")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:FIELD:RATE:SP")
  field(SDIS, "$(P)DISABLE")
}

# The voltage at which the unit will stop ramping/sweeping at the sweeprate
# requested, but reduce it to protect the voltage.
record(ai, "$(P)VOLT:LIMIT:SOFTWARE") {
  field(DESC, "Software voltage limit readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getSoftwareVoltageLimit $(PORT)")
  field(EGU,  "V")
  field(PREC, "8")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:SOFTWAREVOLTAGELIMIT")
  field(SDIS, "$(P)DISABLE")
}

# This is the current that is in the magnet, which in the case of a magnet with a switch
# and a heater is preserved even when the power unit is not connected (cos of how
# superconducting magnets behave).
record(ai, "$(P)MAGNET:CURR:PERSISTENT") {
  field(DESC, "Persistent magnet current readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getPersistentMagnetCurrent $(PORT)")
  field(EGU,  "A")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:PERSISTENTMAGNETCURRENT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The field in the magnet due to the persistent current. See current for explanation.
record(ai, "$(P)MAGNET:FIELD:PERSISTENT") {
  field(DESC, "Persistent magnet field readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getPersistentMagnetField $(PORT)")
  field(EGU,  "T")
  field(PREC, "5")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:PERSISTENTMAGNETFIELD")
  field(SDIS, "$(P)DISABLE")
  
  info(INTEREST, "LOW")
  
  info(archive, "VAL")
}

# The current being provided to the heater.
record(ai, "$(P)HEATER:CURR") {
  field(DESC, "Heater current readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getHeaterCurrent $(PORT)")
  field(EGU,  "mA")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:HEATERCURRENT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The lower limit for the current.  This refers to a limit on the controller and
# is nothing to do with EPICS record limit or alarm fields.
record(ai, "$(P)CURR:LIMIT:NEG") {
  field(DESC, "Neg current limit readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getNegCurrentLimit $(PORT)")
  field(EGU,  "A")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:NEGCURRENTLIMIT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The higher limit for the current.  This refers to a limit on the controller and
# is nothing to do with EPICS record limit or alarm fields.
record(ai, "$(P)CURR:LIMIT:POS") {
  field(DESC, "Pos current limit readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getPosCurrentLimit $(PORT)")
  field(EGU,  "A")
  field(PREC, "4")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:POSCURRENTLIMIT")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The resistance of the lead from the unit to the magnet that carries
# the current.  This is set by the supplier in the controller, all this
# record does is read and report the value.
record(ai, "$(P)RESISTANCE:LEAD") {
  field(DESC, "Leadresistance readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getLeadResistance $(PORT)")
  field(EGU,  "mohm")
  field(PREC, "5")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:LEADRESISTANCE")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# The inductance of the magnet. Believe this is also set by the supplier
# as a calibration.
record(ai, "$(P)MAGNET:INDUCTANCE") {
  field(DESC, "Magnet inductance readback")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getMagnetInductance $(PORT)")
  field(EGU,  "H")
  field(PREC, "5")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:MAGNETINDUCTANCE")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

# --------------- The following work around limitation of getting legacy status from SCPI protocol -------------

# Get the status DWORD from each group UID
record(mbbiDirect, "$(P)GET:MAGNET:SUPPLY:STATUS") {
  field(DESC, "Examine status")
  field(DTYP, "stream")
  field(INP, "@OxInstIPS_SCPI.protocol getMagnetSupplyStatus($(P)) $(PORT)")
  field(NOBT, "32")
  field(SCAN, "1 second")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:DONOTHING")
  field(SDIS, "$(P)DISABLE")
}

# Determine the switch heater mismatch status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:SWHTRMISMATCH") {
  field(DESC, "Switch heater mismatch status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B0 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the Over Temperature (rundown resistors) status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:OTRUNDOWNRES") {
  field(DESC, "Over temp rundown resistors status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B1 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the Over Temperature (sense resistor) status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:OTSENSERES") {
  field(DESC, "Over temp sense resistor status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B2 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the Over Temperature (PCB) status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:OTPCB") {
  field(DESC, "Over temp PCB status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B3 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the calibration failure status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:CALIBFAIL") {
  field(DESC, "Calibration failure status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B4 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the MSP430 firmware error failure status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:FWFAIL") {
  field(DESC, "Firmware failure status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B5 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the rundown resistors failure status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:RRFAIL") {
  field(DESC, "Rundown resistors failure status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B6 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the MSP430 RS-485 failure status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:RS485FAIL") {
  field(DESC, "MSP430 RS485 failure status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B7 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the quench status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:QUENCHED") {
  field(DESC, "Quench status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B8 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the catch detection status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:CATCH") {
  field(DESC, "PSU Catch status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B9 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine the Sense amplifier over temperature status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:OTSENSEAMP") {
  field(DESC, "Over temp sense amp")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.BC CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine amplifier 1 over temperature status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:OTAMP1") {
  field(DESC, "Over temp amp 1")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.BD CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine amplifier 2 over temperature status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:OTAMP2") {
  field(DESC, "Over temp amp 2")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.BE CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine PWM Cutoff status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:PWMCUTOFF") {
  field(DESC, "PWM Cutoff status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.BF CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine Voltage ADC error status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:VADCERROR") {
  field(DESC, "Voltage ADC error status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B10 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# Determine Current ADC error status from the supply status bit
record(bi, "$(P)MAGNET:SUPPLY:STATUS:IADCERROR") {
  field(DESC, "Current ADC error status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)GET:MAGNET:SUPPLY:STATUS.B11 CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# The over temperature status should be an or'd output from the numerous temperature alarms
record(calc, "$(P)MAGNET:SUPPLY:STATUS:OVERTEMP:CALC") {
  field(DESC, "Temperature status calc (combined)")
  field(SCAN, "Passive")
  field(INPA, "$(P)MAGNET:SUPPLY:STATUS:OTRUNDOWNRES CP MS")
  field(INPB, "$(P)MAGNET:SUPPLY:STATUS:OTSENSERES CP MS")
  field(INPC, "$(P)MAGNET:SUPPLY:STATUS:OTPCB CP MS")
  field(INPD, "$(P)MAGNET:SUPPLY:STATUS:OTSENSEAMP CP MS")
  field(INPE, "$(P)MAGNET:SUPPLY:STATUS:OTAMP1 CP MS")
  field(INPF, "$(P)MAGNET:SUPPLY:STATUS:OTAMP2 CP MS")
  field(CALC, "A|B|C|D|E|F")
}

# Determine the Over Temperature status from the or'd calc record (OVERTEMP:CALC)
record(bi, "$(P)MAGNET:SUPPLY:STATUS:OVERTEMP") {
  field(DESC, "Temperature status (combined)")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP, "$(P)MAGNET:SUPPLY:STATUS:OVERTEMP:CALC CP MS")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(ZSV,  "NO_ALARM")
  field(OSV,  "MAJOR")
}

# --------------------------------------------------------------------------------------------------------------

## Derive the SYSTEM:HWFAULT status from the status bits
## This collates the various possible hardware faults into a single record,
## which in the legacy protocol is a single value (Xm bit 4).
record(calc, "$(P)STS:SYSTEM:HWFAULT:CALC") {
  field(DESC, "System hardware fault status calc")
  field(SCAN, "Passive")
  field(INPA, "$(P)MAGNET:SUPPLY:STATUS:SWHTRMISMATCH CP MS")
  field(INPB, "$(P)MAGNET:SUPPLY:STATUS:CALIBFAIL CP MS")
  field(INPC, "$(P)MAGNET:SUPPLY:STATUS:FWFAIL CP MS")
  field(INPD, "$(P)MAGNET:SUPPLY:STATUS:RRFAIL CP MS")
  field(INPE, "$(P)MAGNET:SUPPLY:STATUS:RS485FAIL CP MS")
  field(INPF, "$(P)MAGNET:SUPPLY:STATUS:CATCH CP MS")
  field(INPG, "$(P)MAGNET:SUPPLY:STATUS:PWMCUTOFF CP MS")
  field(INPH, "$(P)MAGNET:SUPPLY:STATUS:VADCERROR CP MS")
  field(INPI, "$(P)MAGNET:SUPPLY:STATUS:IADCERROR CP MS")
  field(CALC, "(A>0||B>0||C>0||D>0||E>0||F>0||G>0||H>0||I>0) ? 1 : 0")
}

## Derive the SYSTEM:FAULT status from the status bits
## This collates the various possible faults into a single record, in alignment with the legacy protocol.
record(calc, "$(P)STS:SYSTEM:FAULT:CALC") {
  field(DESC, "System fault status calc")
  field(SCAN, "Passive")
  field(INPA, "$(P)MAGNET:SUPPLY:STATUS:QUENCHED CP MS")
  field(INPB, "$(P)MAGNET:SUPPLY:STATUS:OVERTEMP CP MS")
  field(INPC, "$(P)STS:SYSTEM:HWFAULT:CALC CP MS")
  field(CALC, "(A>0) ? 1 : (B>0) ? 2 : (C>0) ? 8 : 0")
}

# # Readback from m of Xmn part of Examine command return.
record(mbbi, "$(P)STS:SYSTEM:FAULT") {
  field(DESC, "System fault status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(INP,  "$(P)STS:SYSTEM:FAULT:CALC CP MS")
  field(ZRST, "Normal")
  field(ZRVL, "0")
  field(ZRSV, "NO_ALARM")
  field(ONST, "Quenched")
  field(ONVL, "1")
  field(ONSV, "MAJOR")
  field(TWST, "Overheated")
  field(TWVL, "2")
  field(TWSV, "MAJOR")
  field(FRST, "Warming Up")
  field(FRVL, "4")
  field(FRSV, "MAJOR")
  field(EIST, "Fault")
  field(EIVL, "8")
  field(EISV, "MAJOR")
  
  info(archive, "VAL")
}

# Readback from SWHT command.
# OFF -> switch closed, ON -> switch open.
record(mbbi, "$(P)HEATER:STATUS") {
  field(DESC, "Heater status")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getHeaterStatus $(PORT)")
  field(ZRST, "Off")
  field(ZRVL, "0")
  field(ONST, "On")
  field(ONVL, "1")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:HEATER:STATUS")
  field(SDIS, "$(P)DISABLE")
  
  info(archive, "VAL")
}

record(bo, "$(P)HEATER:STATUS:SP") {
  field(DESC, "Set Remote/Local Control")
  field(DTYP, "stream")
  field(SCAN, "Passive")
  field(OUT,  "@OxInstIPS_SCPI.protocol setHeaterStatus $(PORT)")
  field(ZNAM, "Off")
  field(ONAM, "On")
  
  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:HEATER:STATUS:SP")
  field(SDIS, "$(P)DISABLE")
}

# Amount of time to wait for heater to warm up/cool down.  **CAN CAUSE MAGNET TO QUENCH IF SET TOO LOW**
# Oxford Instruments labview driver uses 30s.  ISIS cryogenics have asked us to increase this to 60s,
# which is more conservative.
# The HEATER_WAITTIME IOC macro, which is _not_ user-facing, has a default of 60s.
# Configurable to lower values to shorten time for IOC tests.

record(ao, "$(P)HEATER:WAITTIME") {
  field(DESC, "Time to wait for heater")
  field(VAL, "$(HEATER_WAITTIME)")
  field(PINI, "YES")
  info(archive, "VAL")
}

# CALC record to coerce heater status values.  Heater can be off in states 0 or 2, and in error in states 5 or 8, 
# and circular buffer (N to 1 Low Value) only looks for lowest (0).
# Output 1 only if heater is on, 0 if off and all other states, including errors.

record(calc, "$(P)HEATER:_STATUS_CALC") {
    field(DESC, "Binary Heater Status")
    field(INPA, "$(P)HEATER:STATUS CP MS")
    field(CALC, "(A=1)?1:0")                # If heater is on, output 1, otherwise 0
    info(archive, "VAL")
}

# COMPRESS Record with circular buffer to store $(HEATER_WAITTIME) worth of HEATER:STATUS values
# Used with second COMPRESS record below to check heater has been on for at least $(HEATER_WAITTIME) after starting IOC

record(compress, "$(P)HEATER:_STATUS_BUFFER") {
  field(DESC, "Buffer of heater status values")
  field(INP, "$(P)HEATER:_STATUS_CALC.VAL")
  field(ALG, "Circular Buffer")
  field(NSAM, "$(HEATER_WAITTIME)")
  field(SCAN, "1 second")
  field(FLNK, "$(P)HEATER:_STATUS_BUFFER_LOWEST")
}

# COMPRESS record to monitor above and output lowest value in buffer.
# If '1' then whole buffer contains '1' and therefore heater has been ON for at least $(HEATER_WAITTIME)
# If '0' then heater has been OFF at some point in $(HEATER_WAITTIME)

record(compress, "$(P)HEATER:_STATUS_BUFFER_LOWEST") {
  field(DESC, "Lowest value of heater status buffer")
  field(INP, "$(P)HEATER:_STATUS_BUFFER")
  field(ALG, "N to 1 Low Value")
  field(NSAM, "1")
  field(N, "$(HEATER_WAITTIME)")
  field(FLNK, "$(P)HEATER:ONTIME_OK")
  info(archive, "VAL")
}

# BO record to indicate whether or not heater been on for at least $(HEATER_WAITTIME).
# Monitored by statemachine to determine whether or not OK to set field.

record(bo, "$(P)HEATER:ONTIME_OK") {
  field(DESC, "Heater on for at least $(HEATER_WAITTIME)s")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(OMSL, "closed_loop")
  field(DOL, "$(P)HEATER:_STATUS_BUFFER_LOWEST.VAL")
  field(ZNAM, "Heater OFF in last $(HEATER_WAITTIME)s")
  field(ONAM, "Heater ON for > $(HEATER_WAITTIME)s")
  info(archive, "VAL")
}

# To capture bits of mismatching status protocol.
# We do not do much with it at the moment.
record(stringin, "$(P)DBG:STS:MISMATCH") {
  field(DESC, "Mismatching protocol string.")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
}

# PERSISTENT pv is the magnet persistent mode in the cryomagnet statemachine.
record(bo, "$(P)PERSISTENT") {
  field(DESC, "Set magnet to persistent")
  field(ZNAM, "NO")
  field(ONAM, "YES")
  field(PINI, "YES")
  info(autosaveFields, "VAL")
  info(INTEREST, "HIGH")
  info(archive, "VAL")
}

# Play nicely with blocks/genie_python
alias("$(P)PERSISTENT", "$(P)PERSISTENT:SP")  


record(mbbo, "$(P)STATEMACHINE") {
  field(DESC, "What the IOC is doing")
  
  field(ZRVL, "0")
  field(ZRST, "Initial state")
  
  field(ONVL, "1")
  field(ONST, "At field")

  field(TWVL, "2")
  field(TWST, "Set PSU to match magnet")

  field(THVL, "3")
  field(THST, "Wait for volts stable")

  field(FRVL, "4")
  field(FRST, "Ensure heater on & warm")

  field(FVVL, "5")
  field(FVST, "Set PSU to setpoint")

  field(SXVL, "6")
  field(SXST, "Turn heater off & wait")

  field(SVVL, "7")
  field(SVST, "Set PSU to zero")
  
  info(archive, "VAL")
}


###
### Records to be more "friendly" to the user.
###

record(calc, "$(P)FIELD:USER") {
    field(DESC, "Field readback")
    field(INPA, "$(P)MAGNET:FIELD:PERSISTENT CP MS")
    field(INPB, "$(P)FIELD CP MS")
    field(INPC, "$(P)HEATER:STATUS CP MS")
    field(CALC, "(C=0||C=2)?A:B")  # If heater is present and switched off, display persistent field, else display PSU field
    field(ASG, "READONLY")
    field(EGU, "T")
    field(PREC, "5")
    info(interest, "HIGH")
    info(archive, "VAL")
}

alias("$(P)FIELD:SP", "$(P)FIELD:USER:SP")  # "User" setpoint is same as "normal" setpoint


### Simulation record - Just to stop errors, doesn't do anything

record(ao, "$(P)SIM:DONOTHING") {}


record(bo, "$(P)SIM:HEATER:STATUS") {
  field(ZNAM, "Off")
  field(ONAM, "On")
}

alias("$(P)SIM:HEATER:STATUS", "$(P)SIM:HEATER:STATUS:SP")

record(ao, "$(P)SIM:MAGNETINDUCTANCE"){}
record(ao, "$(P)SIM:LEADRESISTANCE"){}
record(ao, "$(P)SIM:POSCURRENTLIMIT"){}
record(ao, "$(P)SIM:NEGCURRENTLIMIT"){}
record(ao, "$(P)SIM:HEATERCURRENT"){}
record(ao, "$(P)SIM:TRIPFIELD"){}
record(ao, "$(P)SIM:TRIPCURRENT"){}
record(ao, "$(P)SIM:CURR:RATE"){}
record(ao, "$(P)SIM:SUPPLY:VOLT"){}
record(ao, "$(P)SIM:CURRENT"){}
record(ao, "$(P)SIM:SOFTWAREVOLTAGELIMIT"){}
record(ao, "$(P)SIM:FIELD:RATE"){}
record(ao, "$(P)SIM:FIELD"){}
alias("$(P)SIM:FIELD:RATE", "$(P)SIM:FIELD:RATE:SP")

record(mbbo, "$(P)SIM:ACTIVITY") {
  field(ZRST, "Hold")
  field(ZRVL, "0")
  field(ONST, "To Setpoint")
  field(ONVL, "1")
  field(TWST, "To Zero")
  field(TWVL, "2")
  field(FRST, "Clamp")
  field(FRVL, "4")
}

alias("$(P)SIM:ACTIVITY", "$(P)SIM:ACTIVITY:SP")

# The Display is in Amps or Tesla.  The Magnet Sweep is fast or slow.
record(mbbi, "$(P)SWEEPMODE:PARAMS") {
  field(DESC, "Mode status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZRST, "Amps Fast")
  field(ZRVL, "0")
  field(ONST, "Tesla Fast")
  field(ONVL, "1")
  field(TWST, "Amps Fast")
  field(TWVL, "2")
  field(THST, "Tesla Fast")
  field(THVL, "3")
  field(FRST, "Amps Slow")
  field(FRVL, "4")
  field(FVST, "Tesla Slow")
  field(FVVL, "5")
  field(SXST, "Amps Slow")
  field(SXVL, "6")
  field(SVST, "Tesla Slow")
  field(SVVL, "7")
  field(EIST, "Amps Unaffected")
  field(EIVL, "8")
  field(NIST, "Tesla Unaffected")
  field(NIVL, "9")

  field(VAL, "3")
  field(PINI, "YES")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:SWEEPMODE:PARAMS")
  field(SDIS, "$(P)DISABLE")

  info(archive, "VAL")
}

# In the legacy version, this used to be the readback from n of Mmn part of Examine command return.
# 0 output constant, 1, 2, 3 output changing
# The SCPI protocol doesn't directly offer this, so it has to be derived via the ACTIVITY record (DEV:GRPZ:PSU:ACTN)
# Direction from Alex Jones: "A response of HOLD or CLMP would be equivalent to n=0 in the response of the X command
# in the old protocol. Responses of RTOS or RTOZ would be equivalent to n=1.
# There is no equivalent for the m=0,1 fast/slow ramps, but we do not use this feature anyway."

record(calcout, "$(P)_SWEEPMODE:SWEEP:CALC") {
  field(INPA, "$(P)ACTIVITY.RVAL CP")
  # 0 = HOLD, 1 = RTOS, 2 = RTOZ, 4 = CLMP
  field(CALC, "((A==0)||(A==4))?0:1")
  field(OUT, "$(P)STS:SWEEPMODE:SWEEP PP")
  field(OOPT, "Every Time")
}

record(mbbi, "$(P)STS:SWEEPMODE:SWEEP") {
  field(DESC, "Mode status")
  field(DTYP, "Soft Channel")
  field(SCAN, "Passive")
  field(ZRST, "At rest")
  field(ZRVL, "0")
  field(ONST, "Sweeping")
  field(ONVL, "1")
  field(TWST, "Sweep Limiting")
  field(TWVL, "2")
  field(THST, "Swping & Lmting")
  field(THVL, "3")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:STS:SWEEPMODE:SWEEP")
  field(SDIS, "$(P)DISABLE")

  info(archive, "VAL")
}

# The temperature of the magnet MB1.T1
record(ai, "$(P)TEMP:MAGNET") {
  field(DESC, "Magnet temperature")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getMagnetTemperature $(PORT)")
  field(EGU,  "K")
  field(PREC, "4")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:TEMP:MAGNET")
  field(SDIS, "$(P)DISABLE")

  info(archive, "VAL")
}

# The temperature of the lambda plate DB8.T1
record(ai, "$(P)TEMP:LAMBDAPLATE") {
  field(DESC, "DB8.T1 temperature")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getLambdaPlateTemperature $(PORT)")
  field(EGU,  "K")
  field(PREC, "4")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:TEMP:LAMBDAPLATE")
  field(SDIS, "$(P)DISABLE")

  info(archive, "VAL")
}

# The temperature of the lambda plate DB8.T1
record(ai, "$(P)PRESSURE") {
  field(DESC, "DB5.P1 pressure")
  field(DTYP, "stream")
  field(SCAN, "1 second")
  field(INP,  "@OxInstIPS_SCPI.protocol getPressure $(PORT)")
  field(EGU,  "mBar")
  field(PREC, "4")

  field(SIML, "$(P)SIM")
  field(SIOL, "$(P)SIM:PRESSURE")
  field(SDIS, "$(P)DISABLE")

  info(archive, "VAL")
}
