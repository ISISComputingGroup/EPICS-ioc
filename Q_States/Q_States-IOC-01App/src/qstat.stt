program qstat

/*
As SNL can't do enums natively, or jumping in code, will have to manage this
done is used to indicate that an action is done so that the next action can be dequeued
action is the state to be doing now
action should always be set to -1 when done is set to 1 so that you don't reiterate a state
action_index is the location in the actions array
actions is the list of states to undertake next
The value of action relates to the following behaviours:
action = 0 ==> idle
action = 1 ==> start
action = 2 ==> state 1
action = 3 ==> state 2
action = 4 ==> state 3
action = 5 ==> pause
action = 6 ==> abort

Abort based on a pv
*/

int done = 0;
int action = 0;
int action_index = 0;
int actions[5];
int test_trigger = 0;
char *prefix;
int allow_start = 1;
int start;
int prev_start;
assign start to "{P}START";
monitor start;
int var;
assign var to "{P}VAR";
monitor var;
int type;
assign type to "{P}TYPE";
monitor type;
int abort;
int prev_abort;
assign abort to "{P}ABORT";
monitor abort;
int print = 0;
int pause;
assign pause to "{P}PAUSE";
monitor pause;
int prev_pause;

ss init {
  state start_init {
    when () {
      prefix = macValueGet("P");
    } state init_done
  }
  state init_done {
     when () {
     } state init_done
  }
}

ss abort {
  state abort_init {
    when () {
      prev_abort = abort;
    } state abort_action
  }
  state abort_action {
    when () {
       if (abort != prev_abort) {
         action = 6;
         abort = 0;
         pvPut(abort);
         prev_abort = abort;
         printf("Abort has changed\r\n");
       }
    } state abort_action
  }
}

ss pause {
  state pause_init {
    when () {
      prev_pause = pause;
    } state pause_action
  }
  state pause_action {
    when () {
       if (pause != prev_pause) {
         action = 5;
         prev_pause = pause;
         printf("Pause has changed\r\n");
       }
    } state pause_action
  }
}

ss start {
  state start_init {
    when () {
      prev_start = start;
    } state start_action
  }
  state start_action {
    when () {
       if (start != prev_start) {
         start = 0;
         pvPut(start);
         if (allow_start == 1) {
           allow_start = 0;
           prev_start = start;
           printf("Start has changed\r\n");
           action = 1;
         }
       }
    } state start_action
  }
}

ss action_queue {
  state action_state {
     when (done == 1) {
       /*printf("Do nothing when done is 1\r\n");*/
     } state action_state
     when (action == 0) {
       /*printf("Idle\r\n");*/
     } state action_state
     when (action == 1) {
        printf("Starting\r\n");
        if (type == 0) {
          printf("Type A\r\n");
          actions[0] = 2;
          actions[1] = 3;
          actions[2] = 4;
          actions[3] = 0;
          actions[4] = 0;
        }
        else {
          printf("Type B\r\n");
          actions[0] = 2;
          actions[1] = 4;
          actions[2] = 0;
          actions[3] = 0;
          actions[4] = 0;
        }
        if (pause == 0) {
          action_index = 0;
        }
        else {
          pause = 0;
          pvPut(pause);
        }
        done = 1;
     } state action_state
     when (action == 2) {
        printf("State 1\r\n");
        if (var >= 0) {
          /* Reset the var for testing/examples */
          var = 0;
          pvPut(var);
          done = 1;
        }
     } state action_state
     when (action == 3) {
        printf("State 2\r\n");
        if (var >= 0) {
          /* Reset the var for testing/examples */
          var = 0;
          pvPut(var);
          done = 1;
        }
     } state action_state
     when (action == 4) {
        if (print == 0) {
           print = 1;
           printf("State 3\r\n");
        }
        /* In this state don't wait for the var to continue */
        if (var >= 2) {
          print = 0;
          pvPut(var);
          done = 1;
        }
     } state action_state
     when (action == 5) {
        printf("Pause\r\n");
        allow_start = 1;
        print = 0;
        if (pause == 1) {
          action_index--;
          action = 0;
        }
        else {
          done = 1;
        }
     } state action_state
     when (action == 6) {
        printf("Abort\r\n");
        actions[0] = 0;
        actions[1] = 0;
        actions[2] = 0;
        actions[3] = 0;
        actions[4] = 0;
        action = 0;
        allow_start = 1;
        print = 0;     
     } state action_state
     when () {
       printf("HOW DID YOU GET HERE!!!!\r\n");
     } state action_state
  }
}

ss done {
  state wait_for_done {
    when (done == 1) {
       printf("Done!\r\n");
       done = 0;
       action = actions[action_index];
       if (action == 0) {allow_start = 1;}
       action_index++;
    } state wait_for_done
    when () {
    } state wait_for_done
  }
}