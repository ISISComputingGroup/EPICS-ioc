#
# General reads
#
record(bo, "$(P)READ:PHASEINFO"){
	field(SCAN, "1 second")
	field(OUT, "@devSKFMB350.proto read_phase_info($(P)) $(PORT)")
	field(DTYP, "stream")
}

record(bo, "$(P)READ:ROTATORANGLE"){
	field(SCAN, "1 second")
	field(OUT, "@devSKFMB350.proto read_rotator_angle($(P)) $(PORT)")
	field(DTYP, "stream")
}

record(bo, "$(P)READ:PHASEDELAY"){
	field(SCAN, "1 second")
	field(OUT, "@devSKFMB350.proto read_phase_delay($(P)) $(PORT)")
	field(DTYP, "stream")
}


#
# Start / stop
#
record(bo, "$(P)START"){
	field(OUT, "@devSKFMB350.proto start $(PORT)")
	field(DTYP, "stream")
}

record(bo, "$(P)STOP"){
	field(OUT, "@devSKFMB350.proto stop $(PORT)")
	field(DTYP, "stream")
}


#
# Frequency
#

record(longin, "$(P)FREQ:RAW") {
	field(EGU, "rpm")
}

record(calcout, "$(P)FREQ:CALC") {
	field(DESC, "Converts rpm to Hz")
	field(INPA, "$(P)FREQ:RAW CP MS")
	field(CALC, "A/60")
	field(OUT, "$(P)FREQ PP")
	field(OOPT, "Every Time")
}

record(ai, "$(P)FREQ"){
	field(EGU, "Hz")
}

record(ao, "$(P)FREQ:SP") {
	field(EGU, "Hz")
}

record(calcout, "$(P)FREQ:SP:CALC") {
	field(DESC, "Converts Hz to rpm")
	field(INPA, "$(P)FREQ:SP CP MS")
	field(CALC, "FLOOR(A*60)")  # Have to use FLOOR because the result must be an integer.
	field(OUT, "$(P)FREQ:SP:RAW PP")
	field(OOPT, "Every Time")
}

record(longout, "$(P)FREQ:SP:RAW") {
	field(OUT, "@devSKFMB350.proto set_frequency $(PORT)")
	field(DTYP, "stream")
	field(EGU, "rpm")
}

alias("$(P)FREQ:SP", "$(P)FREQ:SP:RBV")


#
# Phase
#

record(ai, "$(P)PHAS") {
	field(EGU, "us")
}

record(ao, "$(P)PHAS:SP") {
	field(EGU, "us")
}

record(calcout, "$(P)PHAS:SP:CALC") {
	field(DESC, "Converts us to ns")
	field(INPA, "$(P)PHAS:SP CP MS")
	field(CALC, "A*1000")
	field(OUT, "$(P)PHAS:SP:RAW PP")
	field(OOPT, "Every Time")
}

record(ao, "$(P)PHAS:SP:RAW") {
	field(EGU, "ns")
	field(OUT, "@devSKFMB350.proto set_phase $(PORT)")
	field(DTYP, "stream")
}

record(ai, "$(P)PHAS:PERCENTOK") {
}

record(ai, "$(P)PHAS:SP:RBV:RAW") {

}

record(calcout, "$(P)PHAS:SP:RBV:CALC") {
	field(DESC, "Converts raw phase rbv")
	field(INPA, "$(P)PHAS:SP:RBV:RAW CP MS")
	field(CALC, "A/10")
	field(OUT, "$(P)PHAS:SP:RBV PP")
	field(OOPT, "Every Time")
}

record(ai, "$(P)PHAS:SP:RBV") {
	field(EGU, "us")
}


#
# Phase repeatability / gate width
#

record(ai, "$(P)GATE") {

}

record(ao, "$(P)GATE:SP") {
	field(EGU, "us")
}

record(calcout, "$(P)GATE:SP:CALC") {
	field(DESC, "Converts us to ns")
	field(INPA, "$(P)GATE:SP CP MS")
	field(CALC, "A*10")
	field(OUT, "$(P)GATE:SP:RAW PP")
	field(OOPT, "Every Time")
}

record(ao, "$(P)GATE:SP:RAW") {
	field(OUT, "@devSKFMB350.proto set_gate_width $(PORT)")
	field(DTYP, "stream")
}


#
# Interlocks
#

record(longin, "$(P)ILK:RAW") {
    # mbbiDirect doesn't seem to work correctly without this intermediate record. Not sure why.
}


record(mbbiDirect, "$(P)ILK") {
	field(DTYP, "Raw Soft Channel")
	field(INP, "$(P)ILK:RAW CP MS")
	#
	# See DB file interlocks.db to get interlock PVs.
	#
}


#
# Chopper status
#

record(longin, "$(P)STAT:RAW") {
    # mbbiDirect doesn't seem to work correctly without this intermediate record. Not sure why.
}


record(mbbiDirect, "$(P)STAT") {
	field(DTYP, "Raw Soft Channel")
	field(INP, "$(P)STAT:RAW CP MS")
	#
	# See DB file status.db to get status PVs.
	#
}


#
# Angle
#

record(longin, "$(P)ANGLE:ROTATOR:RAW") {
	field(EGU, "degrees")
}

record(calcout, "$(P)ANGLE:ROTATOR:CALC") {
	field(DESC, "Converts us to ns")
	field(INPA, "$(P)ANGLE:ROTATOR:RAW CP MS")
	field(CALC, "A/10")
	field(OUT, "$(P)ANGLE:ROTATOR PP")
	field(OOPT, "Every Time")
}

record(ai, "$(P)ANGLE:ROTATOR") {
	field(EGU, "degrees")
}

record(longout, "$(P)ANGLE:ROTATOR:SP") {
	field(EGU, "degrees")
}

record(calcout, "$(P)ANGLE:ROTATOR:SP:CALC") {
	field(DESC, "Converts us to ns")
	field(INPA, "$(P)ANGLE:ROTATOR:SP CP MS")
	field(CALC, "FLOOR(A*10)")
	field(OUT, "$(P)ANGLE:ROTATOR:SP:RAW PP")
	field(OOPT, "Every Time")
}

record(longout, "$(P)ANGLE:ROTATOR:SP:RAW") {
	field(OUT, "@devSKFMB350.proto set_rotator_angle $(PORT)")
	field(DTYP, "stream")
}
